

Chuy·ªÉn ƒë·∫øn n·ªôi dung
S·ª≠ d·ª•ng Gmail b·∫±ng tr√¨nh ƒë·ªçc m√†n h√¨nh
Cu·ªôc tr√≤ chuy·ªán

C√≥ g·∫Øn d·∫•u sao
 

M·ªçi th·ª© kh√°c
 
1‚Äì50 trong s·ªë 817
 
ƒê√£ d√πng 1% tr√™n t·ªïng s·ªë 15 GB
ƒêi·ªÅu kho·∫£n ¬∑ B·∫£o m·∫≠t ¬∑ Ch√≠nh s√°ch ch∆∞∆°ng tr√¨nh
Ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y nh·∫•t c·ªßa t√†i kho·∫£n: 0 ph√∫t tr∆∞·ªõc
M·ªü t·∫°i 1 v·ªã tr√≠ kh√°c ¬∑ Chi ti·∫øt
<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Qu·∫£n L√Ω Truy·ªán ‚Äî Drive + AI</title>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.5; padding: 16px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .btn { padding: 8px 12px; border: 1px solid #ccc; border-radius: 8px; cursor: pointer; background: #fafafa; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: #0b72ec; color: white; border-color: #0b72ec; }
    .btn-secondary { background: #eee; }
    .muted { color: #666; }
    textarea, input[type="number"], input[type="text"], select { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 8px; }
    .card { border: 1px solid #eee; border-radius: 12px; padding: 12px; margin: 12px 0; }
    #statusLog { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #0f172a; color: #e2e8f0; padding: 12px; border-radius: 8px; max-height: 240px; overflow: auto; white-space: pre-wrap; }
    .grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 16px; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
    .story-content { padding: 12px; border: 1px dashed #ddd; border-radius: 8px; background: #fafafa; }
    .label { font-weight: 600; margin-top: 6px; display: block; }
  </style>

  <!-- Google Identity Services + GAPI -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="https://apis.google.com/js/api.js" async defer
          onload="gapiLoaded()"></script>
</head>
<body>

  <h1>üìö Qu·∫£n L√Ω Truy·ªán ‚Äî Google Drive + AI</h1>

  <div class="card">
    <div class="row">
      <button id="authorize_button" class="btn btn-primary" style="display:none">ƒêƒÉng nh·∫≠p Google</button>
      <button id="signout_button" class="btn btn-secondary" style="display:none">ƒêƒÉng xu·∫•t</button>
      <span class="muted">Th∆∞ m·ª•c ch√≠nh: <code>QuanLyTruyen</code></span>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>üîç Qu√©t & Ph√¢n t√≠ch d·ªØ li·ªáu</h3>
      <div class="row">
        <button id="scanBtn" class="btn">Qu√©t .txt</button>
        <button id="analyzeBtn" class="btn">Ph√¢n t√≠ch</button>
        <button id="downloadScanCacheBtn" class="btn">T·∫£i Scan Cache</button>
        <button id="downloadAnalysisBtn" class="btn">T·∫£i Analysis</button>
        <button id="uploadAnalysisBtn" class="btn">Upload Analysis</button>
        <button id="deleteCacheBtn" class="btn btn-secondary">Xo√° cache</button>
      </div>
      <label class="label">K·∫øt qu·∫£ ph√¢n t√≠ch (r√∫t g·ªçn)</label>
      <div id="analysisPreview" class="story-content"></div>
    </div>

    <div class="card">
      <h3>‚úçÔ∏è Vi·∫øt truy·ªán</h3>
      <div class="row">
        <div style="flex:1">
          <label class="label" for="numChapters">S·ªë ch∆∞∆°ng</label>
          <input id="numChapters" type="number" min="1" max="100" value="5" />
        </div>
        <div style="flex:1">
          <label class="label" for="sensitivitySelect">Phong c√°ch c·∫£m x√∫c</label>
          <select id="sensitivitySelect">
            <option value="b√¨nh th·∫£n">B√¨nh th·∫£n</option>
            <option value="m√£nh li·ªát">M√£nh li·ªát</option>
            <option value="u ho√†i">U ho√†i</option>
            <option value="l·∫°c quan">L·∫°c quan</option>
          </select>
        </div>
      </div>
      <div class="row">
        <button id="generateBtn" class="btn btn-primary">T·∫°o truy·ªán</button>
        <button id="loadStoriesBtn" class="btn">T·∫£i th∆∞ vi·ªán truy·ªán</button>
      </div>

      <label class="label">M√¥ t·∫£ truy·ªán v·ª´a sinh</label>
      <div id="storyPreview" class="story-content"></div>
    </div>
  </div>

  <div class="card">
    <h3>üóÇÔ∏è Th∆∞ vi·ªán truy·ªán (Google Drive)</h3>
    <div id="storiesLibrary">
      <p class="muted">Ch∆∞a c√≥ truy·ªán n√†o trong th∆∞ vi·ªán.</p>
    </div>
  </div>

  <!-- Di chuy·ªÉn readerContainer ra ngo√†i storiesLibrary ƒë·ªÉ kh√¥ng b·ªã ghi ƒë√® -->
  <div id="readerContainer" style="display:none; margin-top:12px;">
    <h3 id="readerTitle">üìñ ƒêang ƒë·ªçc truy·ªán</h3>
    <div id="readerContent" class="story-content"></div>
    <div style="margin-top:10px; display:flex; justify-content:space-between;">
      <button class="btn btn-secondary" onclick="prevChapter()">‚¨ÖÔ∏è Ch∆∞∆°ng tr∆∞·ªõc</button>
      <button class="btn btn-secondary" onclick="nextChapter()">Ch∆∞∆°ng ti·∫øp ‚û°Ô∏è</button>
    </div>
  </div>

  <div class="card">
    <h3>üß™ Ghi ch√∫ h·ªá th·ªëng</h3>
    <div id="statusLog"></div>
  </div>

<script>
/** =========================
 *  C·∫•u h√¨nh Google API
 *  ========================= */
const CLIENT_ID     = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com';
const API_KEY       = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o';
const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
const SCOPES        = 'https://www.googleapis.com/auth/drive.file';

let tokenClient;
let gapi_inited = false;
let gis_inited  = false;

function gapiLoaded() {
  gapi.load('client', initializeGapiClient);
}
async function initializeGapiClient() {
  try {
    await gapi.client.init({
      apiKey: API_KEY,
      discoveryDocs: [DISCOVERY_DOC],
    });
    gapi_inited = true;
    maybeEnableButtons();
    writeDetailedStatus('‚úÖ GAPI ƒë√£ s·∫µn s√†ng.');
  } catch (e) {
    writeDetailedStatus('‚ùå L·ªói init GAPI: ' + e.message);
  }
}
window.onload = () => {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: SCOPES,
    callback: '', // set later
  });
  gis_inited = true;
  maybeEnableButtons();
  bindUIEvents();
  defaultDisableButtons();
};

function maybeEnableButtons() {
  const authBtn = document.getElementById('authorize_button');
  const signOutBtn = document.getElementById('signout_button');
  if (gapi_inited && gis_inited) {
    authBtn.style.display = 'inline-block';
  }
  authBtn.onclick = handleAuthClick;
  signOutBtn.onclick = handleSignoutClick;
}

function handleAuthClick() {
  tokenClient.callback = async (resp) => {
    if (resp.error) { throw(resp); }
    document.getElementById('authorize_button').style.display = 'none';
    document.getElementById('signout_button').style.display = 'inline-block';
    showLoggedInState();
    writeDetailedStatus('üîê ƒêƒÉng nh·∫≠p th√†nh c√¥ng.');
    // c·ªë g·∫Øng load cache
    await loadScanCache();
    await loadAnalysisData();
  };
  if (gapi.client.getToken() === null) {
    tokenClient.requestAccessToken({prompt: 'consent'});
  } else {
    tokenClient.requestAccessToken({prompt: ''});
  }
}
function handleSignoutClick() {
  const token = gapi.client.getToken();
  if (token !== null) {
    google.accounts.oauth2.revoke(token.access_token);
    gapi.client.setToken('');
  }
  document.getElementById('authorize_button').style.display = 'inline-block';
  document.getElementById('signout_button').style.display = 'none';
  showLoggedOutState();
  writeDetailedStatus('üö™ ƒê√£ ƒëƒÉng xu·∫•t.');
}

/** =========================
 *  UI & tr·∫°ng th√°i n√∫t b·∫•m
 *  ========================= */
function defaultDisableButtons() {
  const ids = [
    'scanBtn','analyzeBtn','generateBtn','downloadAnalysisBtn',
    'downloadScanCacheBtn','loadStoriesBtn','uploadAnalysisBtn'
  ];
  ids.forEach(id => { const el = document.getElementById(id); if (el) el.disabled = true; });
}
function showLoggedInState() {
  const enableButtons = [
    'scanBtn','analyzeBtn','generateBtn','downloadAnalysisBtn',
    'downloadScanCacheBtn','loadStoriesBtn','uploadAnalysisBtn'
  ];
  enableButtons.forEach(id => { const el = document.getElementById(id); if (el) el.disabled = false; });
}
function showLoggedOutState() {
  const disableButtons = [
    'scanBtn','analyzeBtn','generateBtn','downloadAnalysisBtn',
    'downloadScanCacheBtn','loadStoriesBtn','uploadAnalysisBtn'
  ];
  disableButtons.forEach(id => { const el = document.getElementById(id); if (el) el.disabled = true; });
  document.getElementById('analysisPreview').innerHTML = '';
  document.getElementById('storyPreview').innerHTML = '';
  document.getElementById('storiesLibrary').innerHTML = '<p class="muted">Ch∆∞a c√≥ truy·ªán n√†o trong th∆∞ vi·ªán.</p>';
  document.getElementById('readerContainer').style.display = 'none';
}
function bindUIEvents() {
  byId('scanBtn').onclick = scanTxtFiles;
  byId('analyzeBtn').onclick = doAnalyze;
  byId('generateBtn').onclick = handleGenerateStory;
  byId('downloadScanCacheBtn').onclick = downloadScanCache;
  byId('downloadAnalysisBtn').onclick = downloadAnalysis;
  byId('uploadAnalysisBtn').onclick = manualUploadAnalysis;
  byId('loadStoriesBtn').onclick = loadStories;
  byId('deleteCacheBtn').onclick = async () => {
    await deleteCache(CACHE_FILE_NAME);
    await deleteCache(ANALYSIS_CACHE_NAME);
    await deleteCache(STORY_CACHE_NAME);
    updateStatus('üßπ ƒê√£ xo√° cache.');
  };
}
function byId(id){ return document.getElementById(id); }
function updateStatus(msg){ const el = byId('statusLog'); el.textContent += (el.textContent? '\n' : '') + msg; el.scrollTop = el.scrollHeight; }
function writeDetailedStatus(msg){ updateStatus(msg); }

/** =========================
 *  H·∫±ng s·ªë t√™n file/folder
 *  ========================= */
const ROOT_FOLDER_NAME     = 'QuanLyTruyen';
const CACHE_FILE_NAME      = 'ScanCache.json';
const ANALYSIS_CACHE_NAME  = 'AnalysisResults.json';
const STORY_CACHE_NAME     = 'GeneratedStories.json';
const CACHE_VERSION        = '2.1.0';

/** =========================
 *  Tr·∫°ng th√°i ·ª©ng d·ª•ng
 *  ========================= */
let scanCache       = { files: [] };
let analysisData    = null;
let generatedStories = [];
let currentRead = { chapters: [], index: 0 };

/** =========================
 *  Helper Google Drive
 *  ========================= */
async function ensureOnlineAndAuth() {
  if (!navigator.onLine) {
    alert('‚ö†Ô∏è B·∫°n ƒëang offline, kh√¥ng th·ªÉ thao t√°c v·ªõi Google Drive.');
    return false;
  }
  if (!gapi_inited || !gapi.client) {
    alert('‚ö†Ô∏è GAPI ch∆∞a s·∫µn s√†ng ho·∫∑c b·∫°n ch∆∞a ƒëƒÉng nh·∫≠p.');
    return false;
  }
  return true;
}
async function getOrCreateRootFolder() {
  const ok = await ensureOnlineAndAuth(); if (!ok) return null;
  const found = await gapi.client.drive.files.list({
    q: `name='${ROOT_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
    fields: 'files(id, name)'
  });
  if (found.result.files.length > 0) return found.result.files[0].id;
  const created = await gapi.client.drive.files.create({
    resource: { name: ROOT_FOLDER_NAME, mimeType: 'application/vnd.google-apps.folder' },
    fields: 'id'
  });
  return created.result.id;
}
/** Upload chu·∫©n ho√° b·∫±ng gapi.client.request() */
async function uploadFileToDrive(fileId, metadata, contentString) {
  try {
    if (fileId) {
      // Update (media)
      await gapi.client.request({
        path: `/upload/drive/v3/files/${fileId}`,
        method: 'PATCH',
        params: { uploadType: 'media' },
        headers: { 'Content-Type': metadata.mimeType || 'application/json' },
        body: contentString
      });
    } else {
      // Create (multipart)
      const boundary = '-------314159265358979323846';
      const delimiter = "\r\n--" + boundary + "\r\n";
      const close_delim = "\r\n--" + boundary + "--";
      const multipartRequestBody =
        delimiter +
        'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
        JSON.stringify(metadata) +
        delimiter +
        'Content-Type: ' + (metadata.mimeType || 'application/json') + '\r\n\r\n' +
        contentString +
        close_delim;
      await gapi.client.request({
        path: '/upload/drive/v3/files',
        method: 'POST',
        params: { uploadType: 'multipart' },
        headers: { 'Content-Type': 'multipart/related; boundary="' + boundary + '"' },
        body: multipartRequestBody
      });
    }
  } catch (error) {
    writeDetailedStatus('‚ùå Upload error: ' + error.message);
  }
}

/** =========================
 *  Cache module (versioned)
 *  ========================= */
async function saveCache(fileName, data) {
  try {
    const ok = await ensureOnlineAndAuth(); if (!ok) return;
    const list = await gapi.client.drive.files.list({
      q: `name='${fileName}' and trashed=false`,
      fields: 'files(id)'
    });
    const cacheContent = {
      version: CACHE_VERSION,
      timestamp: new Date().toISOString(),
      data
    };
    const metadata = { name: fileName, mimeType: 'application/json' };
    const fileId = list.result.files.length > 0 ? list.result.files[0].id : null;
    await uploadFileToDrive(fileId, metadata, JSON.stringify(cacheContent));
    writeDetailedStatus(`‚úÖ Saved cache: ${fileName}`);
  } catch (e) {
    writeDetailedStatus(`‚ùå Error saving cache ${fileName}: ` + e.message);
  }
}
async function loadCache(fileName, maxAgeHours = 24) {
  try {
    const ok = await ensureOnlineAndAuth(); if (!ok) return null;
    const list = await gapi.client.drive.files.list({
      q: `name='${fileName}' and trashed=false`,
      fields: 'files(id, name)'
    });
    if (list.result.files.length === 0) return null;
    const fileId = list.result.files[0].id;
    const res = await gapi.client.drive.files.get({ fileId, alt: 'media' });
    let cache;
    try {
      cache = JSON.parse(res.body);
    } catch (parseErr) {
      writeDetailedStatus(`‚ö†Ô∏è Cache h·ªèng (JSON parse fail): ${fileName} ‚Äî xo√° file.`); 
      await gapi.client.drive.files.delete({ fileId });
      return null;
    }
    if (!cache.version || cache.version !== CACHE_VERSION) {
      writeDetailedStatus(`‚ö†Ô∏è Cache version mismatch: ${fileName}`);
      return null;
    }
    const ageHours = (Date.now() - new Date(cache.timestamp).getTime()) / 36e5;
    if (ageHours > maxAgeHours) {
      writeDetailedStatus(`‚ö†Ô∏è Cache expired (${ageHours.toFixed(1)}h): ${fileName}`);
      return null;
    }
    writeDetailedStatus(`‚úÖ Loaded cache: ${fileName}`);
    return cache.data;
  } catch (e) {
    writeDetailedStatus(`‚ùå Error loading cache ${fileName}: ` + e.message);
    return null;
  }
}
async function deleteCache(fileName) {
  try {
    const ok = await ensureOnlineAndAuth(); if (!ok) return;
    const list = await gapi.client.drive.files.list({
      q: `name='${fileName}' and trashed=false`,
      fields: 'files(id, name)'
    });
    for (const f of list.result.files) {
      await gapi.client.drive.files.delete({ fileId: f.id });
    }
  } catch (e) {
    writeDetailedStatus(`‚ùå Error deleting cache ${fileName}: ` + e.message);
  }
}

/** =========================
 *  Qu√©t & ph√¢n t√≠ch d·ªØ li·ªáu
 *  ========================= */
async function scanTxtFiles() {
  try {
    const ok = await ensureOnlineAndAuth(); if (!ok) return;
    updateStatus('üîé ƒêang qu√©t .txt trong th∆∞ m·ª•c QuanLyTruyen...');
    const rootId = await getOrCreateRootFolder();
    const files = await listTxtFilesDeep(rootId);
    scanCache = { files };
    await saveScanCache();
    byId('analyzeBtn').disabled = files.length === 0;
    byId('downloadScanCacheBtn').disabled = false;
    updateStatus(`‚úÖ Qu√©t xong: ${files.length} file .txt`);
  } catch (e) {
    writeDetailedStatus('‚ùå scanTxtFiles: ' + e.message);
  }
}
async function listTxtFilesDeep(parentId) {
  const all = [];
  async function dfs(folderId) {
    const res = await gapi.client.drive.files.list({
      q: `'${folderId}' in parents and trashed=false`,
      fields: 'files(id, name, mimeType)',
      pageSize: 1000
    });
    for (const f of res.result.files) {
      if (f.mimeType === 'application/vnd.google-apps.folder') {
        await dfs(f.id);
      } else if (f.name.toLowerCase().endsWith('.txt')) {
        all.push(f);
      }
    }
  }
  await dfs(parentId);
  return all;
}
async function doAnalyze() {
  try {
    if (!scanCache || !Array.isArray(scanCache.files) || scanCache.files.length === 0) {
      alert('‚ö†Ô∏è Kh√¥ng c√≥ file .txt ƒë·ªÉ ph√¢n t√≠ch. H√£y qu√©t tr∆∞·ªõc.');
      return;
    }
    updateStatus('üß† ƒêang ph√¢n t√≠ch n·ªôi dung (demo g·ªôp t·ª´ t√™n file)...');
    // DEMO: ph√¢n t√≠ch s∆° b·ªô d·ª±a v√†o t√™n file (th·ª±c t·∫ø b·∫°n thay b·∫±ng ph√¢n t√≠ch th·∫≠t)
    const themes = {};
    const chars  = {};
    for (const f of scanCache.files) {
      const tokens = f.name.toLowerCase().replace('.txt','').split(/[\s\-_]+/);
      tokens.forEach(t => {
        if (t.length >= 3) themes[t] = (themes[t]||0)+1;
      });
      if (tokens[0]) chars[tokens[0]] = (chars[tokens[0]]||0)+1;
    }
    analysisData = {
      thematicAnalysis: Object.entries(themes).sort((a,b)=>b[1]-a[1]).slice(0,8).map(([word,score])=>({word, score})),
      characterAnalysis: Object.entries(chars).sort((a,b)=>b[1]-a[1]).slice(0,5).map(([name,count])=>({name, count})),
      emotionalAnalysis: { dominantEmotion: 'b√¨nh th·∫£n' },
      dialogueAnalysis: { style: 't·ª± nhi√™n' }
    };
    displayAdvancedAnalysisResults();
    await autoSaveAnalysis();
    byId('generateBtn').disabled = false;
    byId('downloadAnalysisBtn').disabled = false;
    updateStatus('‚úÖ Ph√¢n t√≠ch xong.');
  } catch (e) {
    writeDetailedStatus('‚ùå doAnalyze: ' + e.message);
  }
}
function displayAdvancedAnalysisResults() {
  const el = byId('analysisPreview');
  if (!analysisData) { el.innerHTML = '<i class="muted">Ch∆∞a c√≥ d·ªØ li·ªáu</i>'; return; }
  const themes = (analysisData.thematicAnalysis||[]).map(t=>t.word).slice(0,6).join(', ');
  const chars  = (analysisData.characterAnalysis||[]).map(c=>c.name).slice(0,4).join(', ');
  el.innerHTML = `<b>Ch·ªß ƒë·ªÅ:</b> ${themes || '‚Äî'}<br><b>Nh√¢n v·∫≠t:</b> ${chars || '‚Äî'}<br><b>C·∫£m x√∫c:</b> ${analysisData.emotionalAnalysis?.dominantEmotion || '‚Äî'}`;
}
async function saveScanCache(){ await saveCache(CACHE_FILE_NAME, scanCache); }
async function loadScanCache(){
  const data = await loadCache(CACHE_FILE_NAME, 24);
  if (data) {
    scanCache = data;
    byId('analyzeBtn').disabled = (scanCache.files||[]).length === 0;
    byId('downloadScanCacheBtn').disabled = false;
    updateStatus(`üì¶ Scan cache: ${(scanCache.files||[]).length} file`);
    return true;
  }
  return false;
}
async function autoSaveAnalysis(){ await saveCache(ANALYSIS_CACHE_NAME, { analysisData }); }
async function loadAnalysisData(){
  const data = await loadCache(ANALYSIS_CACHE_NAME, 48);
  if (data && data.analysisData) {
    analysisData = data.analysisData;
    displayAdvancedAnalysisResults();
    byId('generateBtn').disabled = false;
    byId('downloadAnalysisBtn').disabled = false;
    updateStatus('üì¶ Analysis cache ƒë√£ t·∫£i.');
    return true;
  }
  return false;
}
function downloadScanCache() {
  const blob = new Blob([JSON.stringify(scanCache,null,2)], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = CACHE_FILE_NAME;
  a.click();
}
function downloadAnalysis() {
  const blob = new Blob([JSON.stringify(analysisData,null,2)], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = ANALYSIS_CACHE_NAME;
  a.click();
}
async function manualUploadAnalysis(){
  if (!analysisData) { alert('‚ö†Ô∏è Ch∆∞a c√≥ analysis ƒë·ªÉ upload'); return; }
  await saveCache(ANALYSIS_CACHE_NAME, { analysisData });
  alert('‚úÖ Upload Analysis th√†nh c√¥ng.');
}

/** =========================
 *  Sinh ti√™u ƒë·ªÅ, m√¥ t·∫£, ƒëo·∫°n vƒÉn (safe)
 *  ========================= */
function generateTitle(analysis) {
  try {
    if (!analysis || !Array.isArray(analysis.thematicAnalysis) || !Array.isArray(analysis.characterAnalysis)) {
      return "Truy·ªán V√¥ Danh " + new Date().getTime();
    }
    const themes = (analysis.thematicAnalysis||[]).slice(0,3).map(t=>t.word || 'b√≠ ·∫©n');
    const characters = (analysis.characterAnalysis||[]).slice(0,2).map(c=>c.name || 'nh√¢n v·∫≠t');
    if (themes.length===0) themes.push('b√≠ ·∫©n');
    while (characters.length<2) characters.push('ng∆∞·ªùi kia');
    const titlePatterns = [
      `${characters[0]} v√† ${characters[1]}`,
      `Cu·ªôc ƒë·ªùi ${characters[0]}`,
      `B√≠ m·∫≠t ${themes[0]}`,
      `${themes[0]} v√† ${themes[1] || 'b√≠ ·∫©n'}`,
      `S·ªë ph·∫≠n ${characters[0]}`,
      `√Ånh s√°ng ${themes[0]}`
    ];
    const title = titlePatterns[Math.floor(Math.random()*titlePatterns.length)];
    return title || "C√¢u Chuy·ªán ƒê·∫∑c Bi·ªát " + new Date().getTime();
  } catch (e) {
    writeDetailedStatus('‚ùå generateTitle: ' + e.message);
    return "Truy·ªán V√¥ Danh " + new Date().getTime();
  }
}
function generateDescription(analysis) {
  try {
    if (!analysis) return "M·ªôt c√¢u chuy·ªán ƒë·∫ßy b√≠ ·∫©n v√† b·∫•t ng·ªù.";
    const themes = (analysis.thematicAnalysis||[]).slice(0,3).map(t=>t.word || 'b√≠ ·∫©n');
    const chars  = (analysis.characterAnalysis||[]).slice(0,2).map(c=>c.name || 'nh√¢n v·∫≠t');
    const emotion= analysis.emotionalAnalysis?.dominantEmotion || 'c·∫£m x√∫c';
    while (themes.length<2) themes.push('b√≠ ·∫©n');
    while (chars.length<2) chars.push('ng∆∞·ªùi kia');
    const arr = [
      `C√¢u chuy·ªán v·ªÅ ${chars[0]} v√† ${chars[1]} trong th·∫ø gi·ªõi ƒë·∫ßy ${themes[0]} v√† ${themes[1]}. M·ªôt h√†nh tr√¨nh ƒë·∫ßy ${emotion}.`,
      `${chars[0]} v·ªën tin r·∫±ng ${themes[0]} l√† t·∫•t c·∫£, cho ƒë·∫øn khi g·∫∑p ${chars[1]}.`,
      `Gi·ªØa nh·ªØng l·ªõp s∆∞∆°ng ${themes[0]}, ${chars[0]} t√¨m ki·∫øm √Ω nghƒ©a c·ªßa ${themes[1]}.`
    ];
    return arr[Math.floor(Math.random()*arr.length)];
  } catch (e) {
    writeDetailedStatus('‚ùå generateDescription: ' + e.message);
    return "M·ªôt c√¢u chuy·ªán ƒë·∫ßy b√≠ ·∫©n.";
  }
}
function generateDescriptiveParagraph(themes=["thi√™n nhi√™n","cu·ªôc s·ªëng","b√≠ ·∫©n"], emotionalStyle="b√¨nh y√™n"){
  const safeThemes = Array.isArray(themes) && themes.length>0 ? themes : ["b√≠ ·∫©n","huy·ªÅn b√≠","kh√≥ l∆∞·ªùng"];
  const arr = [
    `B·∫ßu tr·ªùi thinh l·∫∑ng, c·∫£m gi√°c ${emotionalStyle} lan kh·∫Øp kh√¥ng gian. ${safeThemes[0]} v√† ${safeThemes[1]||'b√≠ ·∫©n'} ho√† v√†o nhau.`,
    `Con ng√µ nh·ªè kh√∫c khu·ª∑u, gi√≥ tho·∫£ng mang m√πi c·ªßa ${safeThemes[2]||safeThemes[0]}.`,
    `CƒÉn ph√≤ng ·∫•m, √°nh ƒë√®n v√†ng d·ªãu. Tr√™n b√†n, ly tr√† to·∫£ h∆∞∆°ng c·ªßa ${safeThemes[1]||'k√Ω ·ª©c'}.`
  ];
  return arr[Math.floor(Math.random()*arr.length)];
}
function generateDialogueParagraph(characters=["Nh√¢n v·∫≠t A","Nh√¢n v·∫≠t B"], dialogueAnalysis={}){
  if (!characters || characters.length<2) characters = ["Ng∆∞·ªùi l·∫°","K·∫ª b√≠ ·∫©n"];
  const a = characters[0], b=characters[1];
  const arr = [
    `${a} nh√¨n ${b}: "M√¨nh ƒë√£ s·∫µn s√†ng ch∆∞a?"\n${b} m·ªâm c∆∞·ªùi: "Ch·ªâ c√≥ c√°ch l√† th·ª≠ th√¥i."`,
    `"Em c√≥ s·ª£ kh√¥ng?" ${a} kh·∫Ω h·ªèi.\n${b} ƒë√°p: "C√≥, nh∆∞ng em tin ·ªü anh."`
  ];
  return arr[Math.floor(Math.random()*arr.length)];
}
function generateActionParagraph(characters=["Nh√¢n v·∫≠t"], themes=["b√≠ ·∫©n"]){
  const c = characters[0] || "Nh√¢n v·∫≠t";
  const arr = [
    `${c} b∆∞·ªõc nhanh qua ng√µ h·∫πp, √°nh m·∫Øt s√°ng l√™n khi th·∫•y d·∫•u v·∫øt m·ªõi.`,
    `${c} si·∫øt ch·∫∑t b√†n tay, quy·∫øt ƒë·ªãnh ƒë·ªëi di·ªán v·ªõi ${themes[0]||'b√≥ng t·ªëi'}.`
  ];
  return arr[Math.floor(Math.random()*arr.length)];
}
function generateReflectionParagraph(characters=["Nh√¢n v·∫≠t"], emotionalStyle="b·ªëi r·ªëi"){
  const c = characters[0] || "Ng∆∞·ªùi k·ªÉ";
  const arr = [
    `${c} ng·ªìi l·∫∑ng nh√¨n ra ngo√†i khung c·ª≠a, m·ªôt d√≤ng ${emotionalStyle} ch·∫£y qua t√¢m tr√≠.`,
    `Trong kho·∫£ng l·∫∑ng, ${c} nh·∫≠n ra ƒëi·ªÅu quan tr·ªçng b·∫•y l√¢u m√¨nh n√© tr√°nh.`
  ];
  return arr[Math.floor(Math.random()*arr.length)];
}
function generateParagraph(analysis, themes, characters, emotionalStyle, sensitivityLevel){
  try{
    const types = ['description','dialogue','action','reflection'];
    const t = types[Math.floor(Math.random()*types.length)];
    if (t==='description') return generateDescriptiveParagraph(themes, emotionalStyle);
    if (t==='dialogue')    return generateDialogueParagraph(characters, analysis?.dialogueAnalysis||{});
    if (t==='action')      return generateActionParagraph(characters, themes);
    if (t==='reflection')  return generateReflectionParagraph(characters, emotionalStyle);
    return 'M·ªôt ƒëo·∫°n vƒÉn ng·∫´u nhi√™n.';
  }catch(e){
    writeDetailedStatus('‚ùå generateParagraph: '+e.message);
    return 'ƒêo·∫°n vƒÉn b·ªã l·ªói khi t·∫°o.';
  }
}
function generateChapterContent(analysis, emotionalStyle="b√¨nh th·∫£n", minWords=600, maxWords=900){
  try{
    const target = Math.floor(Math.random()*(maxWords-minWords+1)) + minWords;
    const themes = (analysis?.thematicAnalysis||[{word:'b√≠ ·∫©n'}]).map(t=>t.word);
    const chars  = (analysis?.characterAnalysis||[{name:'nh√¢n v·∫≠t'}]).map(c=>c.name);
    let content = '', wc = 0, loops = 0, maxLoops = target*3;
    while (wc < target && loops < maxLoops) {
      const p = generateParagraph(analysis, themes, chars, emotionalStyle);
      content += (p||'') + '\n\n';
      wc += (p ? p.split(/\s+/).length : 0);
      loops++;
    }
    return content.trim() || "N·ªôi dung ch∆∞∆°ng t·∫°m th·ªùi r·ªóng.";
  }catch(e){
    writeDetailedStatus('‚ùå generateChapterContent: '+e.message);
    return "N·ªôi dung ch∆∞∆°ng b·ªã l·ªói khi t·∫°o.";
  }
}

/** =========================
 *  Vi·∫øt truy·ªán & l∆∞u Drive
 *  ========================= */
function generateStory(numChapters=5, emotionalStyle="b√¨nh th·∫£n"){
  const story = {
    title: generateTitle(analysisData),
    description: generateDescription(analysisData),
    chapters: []
  };
  for (let i=1;i<=numChapters;i++){
    story.chapters.push({
      title: `Ch∆∞∆°ng ${i}`,
      content: generateChapterContent(analysisData, emotionalStyle)
    });
  }
  return story;
}
async function handleGenerateStory(){
  try{
    if (!analysisData){ alert('‚ö†Ô∏è Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch. H√£y qu√©t & ph√¢n t√≠ch tr∆∞·ªõc.'); return; }
    const numChapters = parseInt(byId('numChapters').value) || 5;
    const style = byId('sensitivitySelect').value || 'b√¨nh th·∫£n';
    const story = generateStory(numChapters, style);
    byId('storyPreview').textContent = story.description;
    const rootId = await getOrCreateRootFolder();
    const storyFolderId = await saveStoryToDrive(story, rootId);
    if (storyFolderId){
      updateStatus(`üìÅ ƒê√£ t·∫°o folder truy·ªán: ${story.title} (id: ${storyFolderId}) c√πng ${story.chapters.length} ch∆∞∆°ng.`);
      // C·∫£i thi·ªán AI b·∫±ng ch√≠nh truy·ªán v·ª´a sinh
      improveAIWithStory(story);
      await autoSaveAnalysis();
      // D·ªçn r√°c n·∫øu c√≥
      await cleanupUntitledFiles(storyFolderId);
    }
  }catch(e){
    writeDetailedStatus('‚ùå handleGenerateStory: '+e.message);
  }
}
async function saveStoryToDrive(story, parentFolderId) {
  try{
    const ok = await ensureOnlineAndAuth(); if (!ok) return null;
    // T·∫°o folder truy·ªán
    const folder = await gapi.client.drive.files.create({
      resource: {
        name: story.title,
        mimeType: 'application/vnd.google-apps.folder',
        parents: [parentFolderId]
      },
      fields: 'id'
    });
    const storyFolderId = folder.result.id;

    if (!story.chapters || story.chapters.length===0){
      writeDetailedStatus('‚ö†Ô∏è Story kh√¥ng c√≥ ch∆∞∆°ng n√†o.');
      return storyFolderId;
    }
    // L∆∞u t·ª´ng ch∆∞∆°ng
    for (const ch of story.chapters){
      const fileName = `${ch.title}.txt`;
      const metadata = { name: fileName, mimeType: 'text/plain', parents: [storyFolderId] };
      await uploadFileToDrive(null, metadata, ch.content || '');
    }
    return storyFolderId;
  }catch(e){
    writeDetailedStatus('‚ùå saveStoryToDrive: '+e.message);
    return null;
  }
}

/** =========================
 *  Cleanup r√°c: Untitled, 0 byte, folder r·ªóng
 *  ========================= */
async function cleanupUntitledFiles(parentFolderId){
  try{
    const ok = await ensureOnlineAndAuth(); if (!ok) return;
    // Duy·ªát recursive
    async function sweep(folderId){
      const res = await gapi.client.drive.files.list({
        q: `'${folderId}' in parents and trashed=false`,
        fields: 'files(id, name, mimeType, size)'
      });
      const children = res.result.files || [];
      for (const f of children){
        if (f.mimeType === 'application/vnd.google-apps.folder'){
          await sweep(f.id);
          // Sau khi d·ªçn con, n·∫øu r·ªóng th√¨ xo√°
          const check = await gapi.client.drive.files.list({
            q: `'${f.id}' in parents and trashed=false`,
            fields: 'files(id)', pageSize: 1
          });
          if (check.result.files.length===0){
            await gapi.client.drive.files.delete({ fileId: f.id });
            writeDetailedStatus(`üóëÔ∏è Xo√° folder r·ªóng: ${f.name}`);
          }
        } else {
          const isUntitled = /^Untitled|Kh√¥ng c√≥ t√™n/i.test(f.name);
          const isEmpty = !f.size || parseInt(f.size)===0;
          if (isUntitled || isEmpty){
            await gapi.client.drive.files.delete({ fileId: f.id });
            writeDetailedStatus(`üóëÔ∏è Xo√° file r√°c: ${f.name} (size: ${f.size||0})`);
          }
        }
      }
    }
    await sweep(parentFolderId);
  }catch(e){
    writeDetailedStatus('‚ùå cleanupUntitledFiles: '+e.message);
  }
}

/** =========================
 *  Th∆∞ vi·ªán & Tr√¨nh ƒë·ªçc
 *  ========================= */
async function loadStories(){
  try{
    const ok = await ensureOnlineAndAuth(); if (!ok) return;
    const rootId = await getOrCreateRootFolder();
    const res = await gapi.client.drive.files.list({
      q: `'${rootId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
      fields: 'files(id, name)'
    });
    const stories = res.result.files;
    const lib = byId('storiesLibrary');
    byId('readerContainer').style.display = 'none';
    if (!stories || stories.length===0){
      lib.innerHTML = '<p class="muted">Ch∆∞a c√≥ truy·ªán n√†o trong th∆∞ vi·ªán.</p>';
      return;
    }
    lib.innerHTML = stories.map(s => `
      <div class="card">
        <b>${s.name}</b><br/>
        <button class="btn" onclick="openStoryFolder('${s.id}','${encodeURIComponent(s.name)}')">M·ªü & ƒë·ªçc</button>
      </div>
    `).join('');
  }catch(e){
    writeDetailedStatus('‚ùå loadStories: '+e.message);
  }
}
async function openStoryFolder(folderId, encName){
  try{
    const ok = await ensureOnlineAndAuth(); if (!ok) return;
    const name = decodeURIComponent(encName);
    const res = await gapi.client.drive.files.list({
      q: `'${folderId}' in parents and trashed=false and mimeType!='application/vnd.google-apps.folder'`,
      fields: 'files(id, name)',
      orderBy: 'name_natural'
    });
    const files = res.result.files || [];
    if (files.length===0){ alert('Folder ch∆∞a c√≥ ch∆∞∆°ng.'); return; }
    // T·∫£i n·ªôi dung c√°c file .txt
    const chapters = [];
    for (const f of files){
      const content = await gapi.client.drive.files.get({ fileId: f.id, alt: 'media' });
      chapters.push({ title: f.name.replace(/\.txt$/i,''), content: content.body || '' });
    }
    currentRead = { title: name, chapters, index: 0 };
    showChapter(0);
  }catch(e){
    writeDetailedStatus('‚ùå openStoryFolder: '+e.message);
  }
}
function showChapter(i){
  if (!currentRead.chapters || i<0 || i>=currentRead.chapters.length) return;
  currentRead.index = i;
  byId('readerTitle').textContent = `üìñ ${currentRead.title} ‚Äî ${currentRead.chapters[i].title}`;
  byId('readerContent').textContent = currentRead.chapters[i].content;
  byId('readerContainer').style.display = 'block';
}
function prevChapter(){ showChapter(currentRead.index - 1); }
function nextChapter(){ showChapter(currentRead.index + 1); }

/** =========================
 *  C·∫£i thi·ªán AI sau khi vi·∫øt
 *  ========================= */
function analyzeText(text){
  // DEMO: ph√¢n t√≠ch c·ª±c ƒë∆°n gi·∫£n t·ª´ text (b·∫°n thay b·∫±ng m√¥ h√¨nh/logic th·∫≠t c·ªßa b·∫°n)
  const words = (text||'').toLowerCase().split(/\W+/).filter(w=>w.length>=4);
  const freq = {};
  words.forEach(w => freq[w]=(freq[w]||0)+1);
  const themes = Object.entries(freq).sort((a,b)=>b[1]-a[1]).slice(0,10).map(([word,score])=>({word,score}));
  const chars  = themes.slice(0,3).map(t=>({name: t.word}));
  return {
    thematicAnalysis: themes,
    characterAnalysis: chars,
    emotionalAnalysis: { dominantEmotion: 'b√¨nh th·∫£n' },
    dialogueAnalysis: { style: 't·ª± nhi√™n' }
  };
}
function mergeAnalysisData(oldData, newData){
  if (!oldData) return newData;
  if (!newData) return oldData;
  return {
    thematicAnalysis: [...(oldData.thematicAnalysis||[]), ...(newData.thematicAnalysis||[])].slice(-200),
    characterAnalysis: [...(oldData.characterAnalysis||[]), ...(newData.characterAnalysis||[])].slice(-100),
    emotionalAnalysis: newData.emotionalAnalysis || oldData.emotionalAnalysis,
    dialogueAnalysis: { ...(oldData.dialogueAnalysis||{}), ...(newData.dialogueAnalysis||{}) }
  };
}
function improveAIWithStory(story){
  try{
    if (!story || !Array.isArray(story.chapters) || story.chapters.length===0) return;
    const full = story.chapters.map(ch => ch.content||'').join('\n\n');
    const fresh = analyzeText(full);
    analysisData = mergeAnalysisData(analysisData, fresh);
    displayAdvancedAnalysisResults();
    writeDetailedStatus(`üéØ AI v·ª´a h·ªçc th√™m t·ª´ ${story.chapters.length} ch∆∞∆°ng.`);
  }catch(e){
    writeDetailedStatus('‚ùå improveAIWithStory: '+e.message);
  }
}
</script>

</body>
</html>
index.html 2.txt
Hi·ªÉn th·ªã index.html 2.txt.
